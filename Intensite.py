#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import re

#----------Définition des fonctions----------#

def traitementValeur(string):
    """
    Cette fonction permet de transformer certain format de valeur sous forme de string en float
    :param string: Valeur formatée à transformer en float.
    :return: La valeur fournie, mais sous forme de float.
    """
    # On enlève les caractères qui peuvent potentiellement gêner et qui ne sont pas essentiels aux formats.
    carac = ["\"", "\'"]
    for toStrip in carac:
        string = string.strip(toStrip)

    # Format heures:minutes:secondes : découpe les partie heures/minutes/secondes et les convertis en secondes
    if re.search("^[0-9]+:[0-9][0-9]:[0-9][0-9]$", string):
        split = string.split(":")
        split = [element.replace(",", ".") for element in split]
        value = float(split[0]) * 3600 + float(split[1]) * 60 + float(split[2])

    # Format monnaie : enlève le caractère monnétaire s'il se trouve avant ou après le nombre
    elif re.search("^[$€£¥₹]?[0-9]+[.,]?[0-9]*[$€£¥₹]?$", string):
        for monnaie in ["$", "€", "£", "¥", "₹"]:
            strip = string.strip(monnaie)
        strip = strip.replace(",", ".")
        value = float(strip)

    # Format pourcentage : enlève le pourcentage et renvoie une valeur décimale
    elif re.search("^[0-9]+[.,]?[0-9]*%$", string):
        strip = string.strip("%")
        strip = strip.replace(",", ".")
        value = float(strip)/100

    # Dans ce else il n'y aura que les formats non prévus dans les elif précédent et les nombres
    # de la forme [0-9]*[.,]?[0-9]*
    # Un format non prévu affichera une erreur du type "could not convert string to float", ce qui nous permet de voir
    # Le format à ajouter.
    else:
        # Le float n'acceptant pas les "," on les remplace par des "."
        string = string.replace(",", ".")
        value = float(string)

    return value

def traitementFichier(path, separateur=None):
    """
    Cette fonction permet d'extraire les données d'un fichier sous forme de liste de liste. Il est recommandé de mettre
    la variable de l'expérience en tant que premier élément de la ligne et les mesures ensuite.
    Chaques élément des lignes doivent être séparé par le même séparateur, de plus la fin de la ligne doit contenir
    un retour à la ligne.
    : param path : chemin relatif ou absolu du fichier à traiter
    : param separateur : chaine de caractère séparant les deux colonnes
    : return : Retourne les données du fichier sous forme de liste de liste. Il y a autant de liste que de ligne
    et chaque liste contient autant d'élément qu'il y a de colonne.
    """
    DataTable = []
    data = open(path, "r")
    for line in data:
        # Si la ligne contient un caractère alphabétique ou un + on l'ignore
        if not (re.search("([A-z]|[+])", line)):
            # On enlève le retour à la ligne et les blancs dans la ligne
            line = line.strip()
            # On casse la ligne au niveau de tous les séparateurs ce qui crée une liste de string
            splitedLine = line.split(separateur)
            # On transforme cette liste de string en liste de float et on la stocke dans une liste qui sera
            # notre tableau (une liste de liste). Cependant, le tableau ainsi créer représente une liste de
            # ligne. Idéalement un tableau constitué d'une liste de colonne serait plus manipulable.
            splitedLine = [traitementValeur(element) for element in splitedLine]
            DataTable = DataTable + [splitedLine]
    data.close()
    return DataTable

def transposition(table):
    """
    Cette fonction permet de faire la "transposition" d'une liste de ligne en liste de colonne
    :param table: Tableau à transposer, sous forme de liste de ligne
    :return: Retourne le tableau transposé, sous forme de liste de colonne.
    """
    TransposedTable = []
    # On relève le nombre de lignes qu'il y a dans le tableau
    lineNumber = len(table)
    # On relève le nombre de colonnes qu'il y a dans le tableau
    columnNumber = len(table[0])
    for column in range(0, columnNumber):
        TransposedList = []
        for line in range(0, lineNumber):
            # On fixe la colonne et on récupère toutes les valeurs sur cette colonne dans une liste
            # On stocke ensuite cette liste dans un tableau.
            TransposedList = TransposedList + [table[line][column]]
        TransposedTable = TransposedTable + [TransposedList]
    return TransposedTable

def sortZip(FirstList, SecondList, column):
    """
    Cette fonction permet de trier une liste tout en gardant la correspondance entre 2 valeurs des listes qui ont le
    même index. Les deux listes doivent donc avoir la même longueur.
    :param FirstList: liste de valeurs
    :param SecondList: liste de valeurs de la même longueur
    : column : 0 ou 1, définit quelle liste doit être triée, les autres seront réarranger pour garder la correspondance
    entre les valeurs de la liste 1 et 2.
    :return: Une des deux listes triées et l'autre réarangée de sorte à garder la correspondance initiale
    """
    # On lie les valeurs de la liste1 et de la liste2 en utilisant zip. Cela créer une liste de tuple, dans un tuple
    # se trouve les éléments des 2 listes qui ont le même index.
    ZippedLists = list(zip(FirstList, SecondList))
    # On trie le zip par rapport aux éléments des tuples qui ont l'index "column".
    SortedZippedLists = sorted(ZippedLists, key=lambda x: x[column])
    # Pour récupérer les 2 listes, on utilise zip à nouveau, mais avec en paramètre tous les tuples du zip qu'on
    # vient de manipuler, c'est * qui permet de récupérer tous les tuples. De cete manière, on obtient 2 tuples
    # un trié et l'autre réarrangé pour garder la correspondance entre les valeurs de même index.
    tuple1, tuple2 = list(zip(*SortedZippedLists))
    # On transforme les tuples en liste, car les listes sont plus pratiques.
    FirstList, SecondList = list(tuple1), list(tuple2)
    return FirstList, SecondList

def dictionnaireFenetre(WindowingList, WindowedList, windowSize=10.0):
    """
    Cette fonction permet de casser la Liste 2 en plusieurs fenetre d'une certaine taille.
    Ces fenêtres sont déterminées par la Liste1 et la taille des fenêtres.
    Pour ce faire chaque liste est stockée dans un dictionnaire, elles ont pour clef le début
    et la fin de la fenêtre
    : param Liste1 : Liste de float triée par ordre croissant
    : param Liste2 : Liste de float (peut être triée) telle que len(Liste1) = len(Liste2)
    : param taille : Taille de l'intervalle, c'est-à-dire fin - début, 10 par défaut
    : return : Dictionnaire qui a pour :
        - clef : un string de la forme "{début fenêtre} - {debut fenêtre + taille}"
        - valeur : une liste triée des valeurs de Liste2 associées aux valeurs de Liste1 dans la fenêtre.
    """
    dictionary = {}
    # On trie la liste1 car on utilisera le fait que liste1[0] est le plus petit élément
    # et liste1[-1] est le plus grand.
    WindowingList, WindowedList = sortZip(WindowingList, WindowedList, 0)
    # La toute première valeur de la première fenêtre est la toute première valeur de la liste 1 arrondie
    # à l'inferieur. On le fait pour avoir des intervalles un peu plus propre.
    windowStart = int(WindowingList[0])
    # A ce stade la on a fin = debut
    windowFinish = windowStart
    # tant que la valeur de fin de fenêtre est inférieure à la dernière valeur de la liste 1...
    while windowFinish < WindowingList[-1]:
        Window = []
        ValueInWindow = []
        # À ce stade-là, on a fin = debut + taille
        windowFinish = windowFinish + windowSize
        # On parcourt tous les éléments de la Liste1
        for element in WindowingList:
            # Si l'élément est compris dans la fenêtre, on stocke l'élément de la liste 1 et celui qui a
            # le même indice dans la liste 2
            if windowStart <= element < windowFinish:
                index = WindowingList.index(element)
                Window = Window + [WindowingList[index]]
                ValueInWindow = ValueInWindow + [WindowedList[index]]
        # Si la liste n'est pas vide On stocke Liste2Fenetre dans le dictionnaire avec pour clef "debut-fin".
        if len(Window) != 0:
            keyStart = Window[0]
            keyFinish = Window[-1]
            key = f"{keyStart:.2f} - {keyFinish:.2f}"
            dictionary[key] = dictionary.get(key, sorted(ValueInWindow))
        # Pour démarrer la boucle suivante, on dit que la fin de cette fenêtre sera le début de la
        # suivante.
        windowStart = windowFinish
    return dictionary

#----------Extraction des paramètres----------#

# Le numéro de colonnes donné étant "naturel" on le réduit de 1 pour l'avoir en index.
parameterColumn = int(sys.argv[5]) - 1
variableColumn = int(sys.argv[6]) - 1

#----------Extraction des données----------#

# On extrait les données sous forme de liste de ligne.
# Si la valeur du deuxième argument est du type défaut/none/default on lance la fonction avec pour
# séparateur, le séparateur par défaut "None".
if re.search("(d[ée]faul?t|none)", sys.argv[2].lower()):
    Data = traitementFichier(sys.argv[1])
# Sinon on lance la fonction avec le séparateur spécifié
else:
    Data = traitementFichier(sys.argv[1], sys.argv[2])

#----------Traitements des donées----------#

# On transpose le tableau pour avoir une liste de colonne
Data = transposition(Data)

# On utilise la liste de colonne
# Si la valeur du troisième argument est du type défaut/none/default on lance la fonction avec pour
# taille de fenêtre, la valeur par défaut 10.
if re.search("(d[ée]faul?t|none)", sys.argv[3].lower()):
    dict = dictionnaireFenetre(Data[parameterColumn], Data[variableColumn])
# Sinon on le lance avec la valeur donnée
else:
    dict = dictionnaireFenetre(Data[parameterColumn], Data[variableColumn], traitementValeur(sys.argv[3]))

for i in dict:
    if len(dict.get(i)) != 0:
        print(f"Voici les information concernant La fenêtre {i} :\n"
            f"    - Elle contient {len(dict.get(i))} valeurs\n" # Nombre d'éléments dans l'intervalle
            f"    - La valeur minimale est {dict.get(i)[0]}\n" # Intensité minimale dans l'intervalle
            f"    - La valeur maximale est {dict.get(i)[-1]}\n" # Intensité maximale dans l'intervalle
            f"    - La valeur moyenne est {sum(dict.get(i)) / len(dict.get(i)):.3f}\n") # Intensité moyenne dans l'intervalle