#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import re

def traitementValeur(string):
    """
    Cette fonction permet de transformer certain format de valeur sous forme de string en float
    :param string: Valeur formatée à transformer en float.
    :return: La valeur fournie, mais sous forme de float.
    """
    # On enlève les caractères qui peuvent potentiellement gêner et qui ne sont pas essentiels aux formats.
    carac = ["\"", "\'"]
    for toStrip in carac:
        string = string.strip(toStrip)
    # Format heures:minutes:secondes : découpe les partie heures/minutes/secondes et les convertis en secondes
    if re.search("^[0-9]+:[0-9][0-9]:[0-9][0-9]$", string):
        split = string.split(":")
        split = [element.replace(",", ".") for element in split]
        valeur = float(split[0]) * 3600 + float(split[1]) * 60 + float(split[2])
    # Format monnaie : enlève le caractère monnétaire s'il se trouve avant ou après le nombre
    elif re.search("^[$€£¥₹]?[0-9]+[.,]?[0-9]*[$€£¥₹]?$", string):
        for monnaie in ["$", "€", "£", "¥", "₹"]:
            strip = string.strip(monnaie)
        strip = strip.replace(",", ".")
        valeur = float(strip)
    # Format pourcentage : enlève le pourcentage et renvoie une valeur décimale
    elif re.search("^[0-9]+[.,]?[0-9]*%$", string):
        strip = string.strip("%")
        strip = strip.replace(",", ".")
        valeur = float(strip)/100
    # Dans ce else il n'y aura que les formats non prévus dans les elif précédent et les nombres
    # de la forme [0-9]*[.,]?[0-9]*
    # Un format non prévu affichera une erreur du type "could not convert string to float", ce qui nous permet de voir
    # Le format à ajouter.
    else:
        # Le float n'acceptant pas les "," on les remplace par des "."
        string = string.replace(",", ".")
        valeur = float(string)
    return valeur

def traitementFichier(path, separateur=None):
    """
    Cette fonction permet d'extraire les données d'un fichier sous forme de liste de liste. Il est recommandé de mettre
    la variable de l'expérience en tant que premier élément de la ligne et les mesures sur les autres colonnes. Chaques
    élément des lignes doivent être séparé par le même séparateur, de plus la fin de la ligne doit contenir un retour
    à la ligne
    : param path : chemin relatif ou absolu du fichier à traiter
    : param separateur : chaine de caractère séparant les deux colonnes
    : return : Retourne les données du fichier sous forme de liste de liste. Il y a autant de liste que de ligne
    et chaque ligne contient autant d'élément qu'il y a de colonne.
    """
    DataTable = []
    data = open(path, "r")
    for line in data:
        # Si la ligne ne contient que des chiffres ont l'extrait et on la traite
        if not (re.search("([A-z]|[+])", line)):
            # On enlève le retour à la ligne
            line = line.strip()
            # On casse la ligne au niveau de tous les séparateurs ce qui crée une liste de string
            splitedLine = line.split(separateur)
            # On transforme cette liste de string en liste de float et on la stocke dans une liste.
            # On a ainsi une liste de liste, un tableau.
            splitedLine = [traitementValeur(element) for element in splitedLine]
            DataTable = DataTable + [splitedLine]
    data.close()
    return DataTable

def transposition(tableau):
    """
    Cette fonction permet de faire la "transposition" d'une liste de ligne en liste de colonne
    :param tableau: Tableau à transposer, sous forme de liste de ligne
    :return: Retourne le tableau transposé, sous forme de liste de colonne.
    """
    TableauTranspose = []
    # On relève le nombre de lignes qu'il y a dans le tableau
    lineNumber = len(tableau)
    # On relève le nombre de colonnes qu'il y a dans le tableau
    columnNumber = len(tableau[0])
    for column in range(0, columnNumber):
        ListeTranspose = []
        for line in range(0, lineNumber):
            # On fixe la colonne et on récupère toutes les valeurs sur cette colonne dans une liste
            # On stocke ensuite cette liste dans un tableau.
            ListeTranspose = ListeTranspose + [tableau[line][column]]
        TableauTranspose = TableauTranspose + [ListeTranspose]
    return TableauTranspose

def dictionnaireFenetre(Liste1, Liste2, taille=10.0):
    """
    Cette fonction permet de casser la Liste 2 en plusieurs fenetre d'une certaine taille.
    Ces fenêtres sont déterminées par la Liste1 et la taille des fenêtres.
    Pour ce faire chaque liste est stockée dans un dictionnaire, elles ont pour clef le début
    et la fin de la fenêtre
    : param Liste1 : Liste de float triée par ordre croissant
    : param Liste2 : Liste de float (peut être triée) telle que len(Liste1) = len(Liste2)
    : param taille : Taille de l'intervalle, c'est-à-dire fin - début, 10 par défaut
    : return : Dictionnaire qui a pour :
        - clef : un string de la forme "{début fenêtre} - {debut fenêtre + taille}"
        - valeur : une liste triée des valeurs de Liste2 associées aux valeurs de Liste1 dans la fenêtre.
    """
    dictionnaire = {}
    # La toute première valeur de la première fenêtre est la toute première valeur de la liste 1 arrondie
    # à l'inferieur. On le fait pour avoir des intervalles un peu plus propre.
    debut = int(Liste1[0])
    # A ce stade la on a fin = debut
    fin = debut
    # tant que la valeur de fin de fenêtre est inférieure à la dernière valeur de la liste 1
    while fin < Liste1[-1]:
        Liste2Fenetre = []
        Liste1Fenetre = []
        # À ce stade-là, on a fin = debut + taille
        fin = fin + taille
        # On parcourt tous les éléments de la Liste1
        for element in Liste1:
            # Si l'élément est compris dans la fenêtre, on stocke l'élément de la liste 1 et celui qui a
            # le même indice dans la liste 2
            if debut <= element < fin:
                k = Liste1.index(element)
                Liste1Fenetre = Liste1Fenetre + [Liste1[k]]
                Liste2Fenetre = Liste2Fenetre + [Liste2[k]]
        # On a une correspondance un pour un entre les éléments de la liste1 et la liste2. Pour enregistrer cette
        # correspondance, on "zip" les 2 listes
        ListeZipped = list(zip(Liste1Fenetre, Liste2Fenetre))
        # On trie la liste zippée en fonction de la Liste2fenetre.
        ListeZippedSorted = sorted(ListeZipped, key=lambda x: x[1])
        # On récupère les deux listes, la deuxième étant triée
        if len(ListeZippedSorted) != 0:
            Liste1Fenetre, Liste2Fenetre = list(zip(*ListeZippedSorted))
        else:
            Liste1Fenetre, Liste2Fenetre = (), ()
        # On stocke Liste2Fenetre dans le dictionnaire avec pour clef "debut-fin".
        dictionnaire[Liste1Fenetre] = dictionnaire.get(Liste1Fenetre, Liste2Fenetre)
        # Pour démarrer la boucle suivante, on dit que la fin de cette fenêtre sera le début de la
        # suivante.
        debut = fin
    return dictionnaire


# On extrait les données sous forme de liste de ligne.
# Si la valeur du deuxième argument est du type défaut/none/default on lance la fonction avec pour
# séparateur, le séparateur par défaut "None".
if re.search("(d[ée]faut|none|default)", sys.argv[2].lower()):
    Donnees = traitementFichier(sys.argv[1])
# Sinon on lance la fonction avec le séparateur spécifié
else:
    Donnees = traitementFichier(sys.argv[1], sys.argv[2])

# On transpose le tableau pour avoir une liste de colonne
Donnees = transposition(Donnees)

# On utilise la liste de colonne
# Le nombre de colonnes donné étant "naturel" on le réduit de 1 pour l'avoir en index.
colonne1 = int(sys.argv[5]) - 1
colonne2 = int(sys.argv[6]) - 1
# Si la valeur du troisième argument est du type défaut/none/default on lance la fonction avec pour
# taille de fenêtre, la valeur par défaut 10.
if re.search("(d[ée]faut|none|default)", sys.argv[3].lower()):
    dict = dictionnaireFenetre(Donnees[colonne1], Donnees[colonne2])
# Sinon on le lance avec la valeur donnée
else:
    dict = dictionnaireFenetre(Donnees[colonne1], Donnees[colonne2], float(sys.argv[3]))

for i in dict:
    if len(dict.get(i)) != 0:
        print(f"Voici les information concernant La fenêtre {i} :\n"
            f"    - Elle contient {len(dict.get(i))} valeurs\n" # Nombre d'éléments dans l'intervalle
            f"    - La valeur minimale est {dict.get(i)[0]}\n" # Intensité minimale dans l'intervalle
            f"    - La valeur maximale est {dict.get(i)[-1]}\n" # Intensité maximale dans l'intervalle
            f"    - La valeur moyenne est {sum(dict.get(i)) / len(dict.get(i)):.3f}\n") # Intensité moyenne dans l'intervalle